package filters_test

import (
	"fmt"
	"math"
	"testing"

	"github.com/IJJA3141/GoSCII/filters"
)

const precision = 50
const tolerance = 0.01

func TestGrayScalePlane_SobelEdgeDetection(t *testing.T) {
	tests := []struct {
		name string // description of this test case
		// Named input parameters for receiver constructor.
		image *filters.GrayScalePlane
		want  float64
	}{
		{
			name: "0°",
			image: &filters.GrayScalePlane{
				Shades: []float64{
					000, 000, 000, 000, 000, 255, 255, 255, 255, 255,
					000, 000, 000, 000, 000, 255, 255, 255, 255, 255,
					000, 000, 000, 000, 000, 255, 255, 255, 255, 255,
					000, 000, 000, 000, 000, 255, 255, 255, 255, 255,
					000, 000, 000, 000, 000, 255, 255, 255, 255, 255,
					000, 000, 000, 000, 000, 255, 255, 255, 255, 255,
					000, 000, 000, 000, 000, 255, 255, 255, 255, 255,
					000, 000, 000, 000, 000, 255, 255, 255, 255, 255,
					000, 000, 000, 000, 000, 255, 255, 255, 255, 255,
					000, 000, 000, 000, 000, 255, 255, 255, 255, 255,
				},
				Width:  10,
				Height: 10,
				Stride: 10,
			},
			want: 0,
		},
		{
			name: "π/4°",
			image: &filters.GrayScalePlane{
				Shades: []float64{
					000, 000, 000, 000, 000, 000, 000, 000, 000, 255,
					000, 000, 000, 000, 000, 000, 000, 000, 255, 255,
					000, 000, 000, 000, 000, 000, 000, 255, 255, 255,
					000, 000, 000, 000, 000, 000, 255, 255, 255, 255,
					000, 000, 000, 000, 000, 255, 255, 255, 255, 255,
					000, 000, 000, 000, 255, 255, 255, 255, 255, 255,
					000, 000, 000, 255, 255, 255, 255, 255, 255, 255,
					000, 000, 255, 255, 255, 255, 255, 255, 255, 255,
					000, 255, 255, 255, 255, 255, 255, 255, 255, 255,
					255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
				},
				Width:  10,
				Height: 10,
				Stride: 10,
			},
			want: math.Pi / 4,
		},
		{
			name: "π/2°",
			image: &filters.GrayScalePlane{
				Shades: []float64{
					000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
					000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
					000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
					000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
					000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
					255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
					255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
					255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
					255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
					255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
				},
				Width:  10,
				Height: 10,
				Stride: 10,
			},
			want: math.Pi / 2,
		},
		{
			name: "π°",
			image: &filters.GrayScalePlane{
				Shades: []float64{
					255, 255, 255, 255, 255, 000, 000, 000, 000, 000,
					255, 255, 255, 255, 255, 000, 000, 000, 000, 000,
					255, 255, 255, 255, 255, 000, 000, 000, 000, 000,
					255, 255, 255, 255, 255, 000, 000, 000, 000, 000,
					255, 255, 255, 255, 255, 000, 000, 000, 000, 000,
					255, 255, 255, 255, 255, 000, 000, 000, 000, 000,
					255, 255, 255, 255, 255, 000, 000, 000, 000, 000,
					255, 255, 255, 255, 255, 000, 000, 000, 000, 000,
					255, 255, 255, 255, 255, 000, 000, 000, 000, 000,
					255, 255, 255, 255, 255, 000, 000, 000, 000, 000,
				},
				Width:  10,
				Height: 10,
				Stride: 10,
			},
			want: math.Pi,
		}, {
			name: "3π/2°",
			image: &filters.GrayScalePlane{
				Shades: []float64{
					255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
					255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
					255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
					255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
					255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
					000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
					000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
					000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
					000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
					000, 000, 000, 000, 000, 000, 000, 000, 000, 000,
				},
				Width:  10,
				Height: 10,
				Stride: 10,
			},
			want: 3 * math.Pi / 2,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := tt.image.SobelEdgeDetection()
			failed := false

			for j := 3; j < got.Height-3 && !failed; j++ {
				for i := 3; i < got.Width-3 && !failed; i++ {
					index := j*got.Stride + i*2
					angle := got.Gradient[index+1]
					failed = got.Gradient[index] >= precision && !(tt.want-tolerance <= angle && angle <= tt.want+tolerance)
				}
			}

			if failed {
				t.Errorf("want %v", tt.want)

				for j := 3; j < got.Height-3; j++ {
					for i := 3; i < got.Width-3; i++ {
						index := j*got.Stride + i*2

						if got.Gradient[index] > 50 {
							fmt.Printf("%f\t", got.Gradient[index+1])
						} else {
							fmt.Printf("\t\t")
						}
					}
					fmt.Println()
				}
			}
		})
	}
}
